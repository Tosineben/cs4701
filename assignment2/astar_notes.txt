
if we know the g value for every node, then we know the g value of the end node, and this is the solution!
if we know the h value for every node, then we know the h value of the start node, and this is the solution!
when we first find the goal node, this must be the cheapest path, so this g^ is g, and we're done!

c = cost function, cost of applying an operator
g(n) = minimum cost path from Si to n
	capturing a memory of the path or a history
g^(n) = minimal cost path found during search, estimate for g
h(n) = minimum cost path from n to Sg
	statnds for heuristic (a rule of thumb, something that helps you find something)
	Example: maybe in 8 puzzle, count number of misplaced tiles, THAT is h
	I've gotten to the same state twice
		First path took 1000 steps and has 5 misplaced tiles
		Second path took 500 steps and has 10 misplaced tiles
		Use BOTH g and h to figure things out
h^(n) = heuristic evalution, estimate for h
f(n) = g(n) + h(n)
	algorithm idea: for every node, choose path with smallest f
	All f values on minimal cost path nodes are equal!
	g(Si) = 0, h(Si) = minimal cost
	g(Sg) = minimal cost path, h(Sg) = 0

if h^=0, then we know h^ is strictly < h
BUT this means we have no knowledge
	this is just uniform cost search!
	and if cost is 0, this is just breadth first search

if h^ < h, ignorant
if h^ = h, brilliant
if h^ > h, stupid

We gaurenteed that g is strictly increasing
	Therefore optimizing with g means we will always find optimal solution once we get to goal state
As long as h^ is not stupid, we can use f^ and be fine, because f^ is monotonically increasing
if h^ is bounded by h, h is 0 at Sg, and we know g^=g at Sg, so f^=f and we're good
h^ is just a function, give it a state it gives you a number (it is not increasing or decreasing)


A* ALGORITHM:

node = (State Operator g^ s^ Parent)

1. put Si on OPEN with g^(Si) = 0, calculate h^(Si)
2. if OPEN = nil
	exit fail
3. Let N in OPEN with minimal f^(n) ;; next f will always be equal or greater than
	pop N from OPEN
	push N onto CLOSED
	if state(N) == Sg
		exit TraceSolution(n) ;; f^(N) wins if h^ <= h
4. for all m in Successors(N) ;; do NOT check for m == Sg
	if mnew not in (OPEN OR CLOSED) ;; m can be in here 3 times, SAME EXACT STATE with different parents, h^ is the same for all of them, so keep parent with smallest g^
		push m on OPEN with g^(m) = c(N, m) + g^(N), h^(m)
	else if mnew in OPEN
		if g^(mopen) > g^(N) + c(N, mnew)
			reset g^(mopen) = g(mnew)
			reset parent(mopen) to N
	else if mnew in CLOSED ;; in uniform cost search, we never had to ask this question
		if g^(mclosed) > g^(N) + c(N, mnew) ;; uh oh, now we need to fix all children of m's because they had the wrong g^! but wait...
			reset g^(mclosed) = g^(mnew)
			reset parent(mclosed) to N
			move mclosed to OPEN ;; bam! this means that in the future, it will get re-expanded, and it's children will get re-expanded with correct g^

Best first search (problem, eval-func)
	1 put si on OPEN
	2 choose n in OPEN with min(apply eval-func)
	3 if N == Sg, exit success
	4 expand N, daughters = successors(N)
	5 check for cycles, prune
	6 update OPEN

possible eval-func (used to select next node from open list)
	min(depth) ;; breadth first search (ignores cost)
	-min(depth) OR max(depth) ;; depth first search
	min(g^) ;; makes uniform cost search!
	min(f^) ;; makes A* search!
	min(h^) ;; what does that do?? greedy (ignores past)

pseudocode from http://www.heyes-jones.com/astar.html
	1 	Create a node containing the goal state node_goal
	2	Create a node containing the start state node_start
	3	Put node_start on the open list
	4	while the OPEN list is not empty
	5	{
	6		Get the node off the open list with the lowest f and call it node_current
	7	 	if node_current is the same state as node_goal we have found the solution; break from the while loop
	8	    Generate each state node_successor that can come after node_current
	9	    for each node_successor of node_current
	10	    {
	11	        Set the cost of node_successor to be the cost of node_current plus the cost to get to node_successor from node_current
	12	        find node_successor on the OPEN list
	13	        if node_successor is on the OPEN list but the existing one is as good or better then discard this successor and continue
	14	        if node_successor is on the CLOSED list but the existing one is as good or better then discard this successor and continue
	15	        Remove occurences of node_successor from OPEN and CLOSED
	16	        Set the parent of node_successor to node_current
	17	        Set h to be the estimated distance to node_goal (Using the heuristic function)
	18	        Add node_successor to the OPEN list
	19	    }
	20	    Add node_current to the CLOSED list
	21	}

8-puzzle h function
	a. number of misplaced tiles
	b. Nilsson's sequence score:
		1 t1= sum manhatten distances each tile has to move to be correct (ignore space)
		2 t2= (+1 if blank not in center) + (+2 foreach tile where clockwise follower is wrong)
		3 return t1 + 3*t2

-----------------------------------
next lecture
-----------------------------------

heuristic evaluation functions h^
	admissible if h^ <= h
	consistent if h^(n) <= c(n, n') + h^(n')
		triangle inequality with three nodes: n, n', Sg

A* with consistent h^ will expand
	all nodes with g^(n) + h^(n) < f(Si)
	some nodes with g^(n) + h^(n) = f(Si)
	and no nodes with g^(n) + h^(n) > f(Si)

A* with admissible h^ will expand
	all nodes with g^(n) + h^(n) < f(Si)

iterative deepening A*
	start with some f-limit and do DFS
		what to start with?
		=> chose f^(Si) = h^(Si) as limit to start because as long as h^ is admissible, answer must be at least h^(Si)
	if no solution, increment f-limit and try again
		how much to increment?
		=> use smallest f^ you found that is larger than f^ you just used

bidrectional A*
	run into same problem of finding the middle

preperties of greedy search
	complete?
		no, can get stuck in loops, depends completely on h^
	time?
		exponential time, but good heuristic can improve
	space?
		exponential space, all nodes in memory
	optimal?
		nope

properties of A*
	complete?
		yes
	time?
		exponential
	space?
		exponential - but iterative deepening A* can fix this
	optimal?
		yes



